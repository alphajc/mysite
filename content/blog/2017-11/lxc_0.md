+++
author = "Jerry Chan"
categories = ["技术"]
tags = ["LXC", "Container"]
date = "2017-11-05T08:56:09+08:00"
description = "lxc的第一篇文章，主要是一些相关概念的阐述。"
featured = ""
featuredalt = ""
featuredpath = ""
linktitle = ""
title = "LXC简介"
type = "post"

+++

LXC
===

LXC是著名的经过严格测试的底层Linux容器运行库。从2008年开始发展，现已在世界各地的关键生产环境中得到证明。其中一些核心贡献者是帮助在Linux内核中实现各种知名集装箱功能的人员。

系统容器
----

LXC的主要重点是系统容器。也就是说，提供尽可能接近VM但没有运行单独内核并模拟所有硬件的开销的容器。 这是通过内核安全功能（如命名空间，强制访问控制和控制组合）实现的。

非特权容器
-----

非特权容器是没有任何权限运行的容器。这需要对内核中运行容器的用户名空间的支持。用户命名空间合并到主线内核之后，LXC是第一个支持非特权容器的运行库。 实质上，用户名空间隔离给定的UID和GID集合。这通过在主机上的一系列UID和GID之间建立到容器中UID和GID的不同（非特权）范围之间的映射来实现。内核将以这样一种方式转换此映射，即在容器内部，所有UID和GID按照您期望的从主机显示，而在主机上，这些UID和GID实际上是无特权的。例如，在容器内作为UID和GID 0运行的进程可能在主机上显示为UID和GID 100000。可以从相应的用户命名空间手册页中收集实现和工作细节。 由于非特权容器是一种安全增强功能，因此它们自然会受到内核强制执行的一些限制。为了提供一个功能齐全的非特权容器LXC与3个setuid代码交互：

*   lxc-user-nic（setuid帮助器创建一个veth对，并在主机上桥接它）
*   newuidmap（从shawdow库中，设置一个uid映射）
*   newgidmap（从shawdow库中，设置一个gid映射）

一切都是以您自己的用户身份运行，也可以作为用户拥有的uid运行。 一般来说，LXC的目标是利用内核中可用的每个安全功能。这意味着LXC的配置管理将使经验丰富的用户根据自己的需要对LXC进行复杂的调整。 有关LXC安全性的更详细的介绍可以在以下链接中找到：

*   https://linuxcontainers.org/lxc/security/

移除特权
----

LXC在没有正确的配置这些工具的情况下是可以运行的。只不过你这种容器的用途通常是非常有限的。这里突出两个最常见的问题：

1.  网络：没有依赖一个setuid帮助器为非特权用户设置适当的网络设备（参见LXC的`lxc-user-nic`二进制文件），唯一的选择是与主机共享网络命名空间。虽然原则上应该是安全的，但共享主机的网络命名空间仍然是减少隔离的一个步骤，并增加攻击向量。此外，当主机和容器共享相同的网络命名空间时，内核将拒绝任何sysfs挂接。这通常意味着容器内的init二进制文件将无法正确启动。
2.  用户命名空间：如上所述，用户名空间是一个很大的安全性增强。但是，不依赖特权帮助者，主机上无权限的用户只能将自己的UID映射到容器中。然而，标准的POSIX系统需要65536个UID和GID来保证完整的功能。

配置
--

LXC通过一些简单的关键字配置，例如：

*   lxc.rootfs.path
*   lxc.mount.entry

LXC通过使用单点命名空间配置关键字。这意味着复杂的配置关键字（如`lxc.net.0`）会展示各种子项，例如`lxc.net.0.type`，`lxc.net.0.link`，`lxc.net.0.ipv6.address`等一些更精细的配置。 LXC被用作LXD的默认运行库，LXD是容器管理程序，它暴露出设计良好且稳定的REST-api。

内核需求
----

LXC在2.6.32以上的任何内核上运行。所有它需要的是一个功能C编译器。 LXC适用于提供必要内核功能的所有架构。这包括（但不限于）：

*   i686
*   x86_64
*   ppc,ppc64,ppc64le
*   s390x
*   armvl7,arm64

LXC至少还支持以下C标准库：

*   glibc
*   musl
*   bionic(Android's libc)

向后兼容
----

LXC一直专注于强大的向后兼容性。事实上，API从1.0.0版起没有被破坏。主LXC目前处于版本2。
